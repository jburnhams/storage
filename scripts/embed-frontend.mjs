#!/usr/bin/env node
import { execSync } from "node:child_process";
import { readFileSync, readdirSync, statSync, writeFileSync } from "node:fs";
import { extname, join, relative, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = resolve(fileURLToPath(new URL(".", import.meta.url)));
const projectRoot = resolve(__dirname, "..");
const frontendRoot = resolve(projectRoot, "frontend");
const distDir = resolve(frontendRoot, "dist");
const outputFile = resolve(projectRoot, "src/frontend/assets.ts");

// Generate build metadata
const metadataFile = resolve(frontendRoot, "src/build-metadata.json");
const timestamp = new Date().toISOString();
writeFileSync(metadataFile, JSON.stringify({ timestamp }, null, 2));
console.log(`Generated build metadata at ${relative(projectRoot, metadataFile)}`);

console.log("Building frontend with Viteâ€¦");
execSync("npx vite build --config frontend/vite.config.ts", {
  cwd: projectRoot,
  stdio: "inherit",
});

const assetFiles = new Map();

function collectAssets(directory) {
  for (const entry of readdirSync(directory)) {
    const fullPath = join(directory, entry);
    const info = statSync(fullPath);
    if (info.isDirectory()) {
      collectAssets(fullPath);
    } else {
      const relativePath = `/${relative(distDir, fullPath).replace(/\\/g, "/")}`;
      assetFiles.set(relativePath, fullPath);
    }
  }
}

collectAssets(distDir);

function getMimeType(filename) {
  const ext = extname(filename).toLowerCase();
  switch (ext) {
    case ".html": return "text/html; charset=utf-8";
    case ".js": return "application/javascript; charset=utf-8";
    case ".css": return "text/css; charset=utf-8";
    case ".json": return "application/json; charset=utf-8";
    case ".png": return "image/png";
    case ".jpg":
    case ".jpeg": return "image/jpeg";
    case ".svg": return "image/svg+xml";
    case ".ico": return "image/x-icon";
    case ".map": return "application/json; charset=utf-8";
    default: return "application/octet-stream";
  }
}

let assetsOutput = "";
assetsOutput += `export const ASSETS = new Map<string, { type: string, content: Uint8Array | string }>();\n\n`;

for (const [path, fullPath] of assetFiles) {
  const mimeType = getMimeType(path);
  const isText = mimeType.startsWith("text/") || mimeType.startsWith("application/json") || mimeType.startsWith("application/javascript");

  if (isText) {
      const content = readFileSync(fullPath, "utf8");
      // Use JSON.stringify to safely escape the string
      assetsOutput += `ASSETS.set(${JSON.stringify(path)}, { type: ${JSON.stringify(mimeType)}, content: ${JSON.stringify(content)} });\n`;
  } else {
       // For binary files, we need to embed them as Uint8Array
       const content = readFileSync(fullPath);
       const base64 = content.toString('base64');
       // In the worker, we can decode base64 to Uint8Array if needed, or just serve base64 if we change the serving logic.
       // But Uint8Array is better for direct response.
       // Storing as base64 string in source code is standard.
       assetsOutput += `ASSETS.set(${JSON.stringify(path)}, { type: ${JSON.stringify(mimeType)}, content: Uint8Array.from(atob("${base64}"), c => c.charCodeAt(0)) });\n`;
  }
}

// Special handling for index.html to be accessible as FRONTEND_HTML for backward compatibility if needed,
// or just as a named export.
const indexHtmlPath = resolve(distDir, "index.html");
const indexHtml = readFileSync(indexHtmlPath, "utf8");
assetsOutput += `\nexport const FRONTEND_HTML = ${JSON.stringify(indexHtml)};\n`;

const banner = "// Auto-generated by scripts/embed-frontend.mjs. Do not edit by hand.\n";
writeFileSync(outputFile, banner + assetsOutput);
console.log(`Generated embedded frontend assets at ${relative(projectRoot, outputFile)}`);
